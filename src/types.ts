/**
 * Claude TMUX Bridge - Type Definitions
 *
 * This module defines all types for the bridge API, including sessions,
 * events, configuration, and agent adapters.
 */

// =============================================================================
// Agent Types
// =============================================================================

/**
 * Supported agent types. Can be extended with custom adapters.
 */
export type AgentType = 'claude' | 'codex' | string

// =============================================================================
// Session Types
// =============================================================================

/**
 * Session status indicates the current state of a session.
 */
export type SessionStatus = 'idle' | 'working' | 'waiting' | 'offline'

/**
 * Session type indicates how the session was created.
 * - internal: Created by the bridge, full control via tmux
 * - external: Detected via hooks, read-only monitoring
 */
export type SessionType = 'internal' | 'external'

/**
 * Terminal information captured from hook events.
 * Used for identifying and potentially communicating with external sessions.
 */
export interface TerminalInfo {
  /** tmux pane ID (e.g., "%0") */
  tmuxPane?: string
  /** tmux socket path (e.g., "/tmp/tmux-501/default") */
  tmuxSocket?: string
  /** Terminal device (e.g., "/dev/ttys001") */
  tty?: string
}

/**
 * A managed session, either internal (created by bridge) or external (detected via hooks).
 */
export interface Session {
  /** Unique identifier (UUID) generated by the bridge */
  id: string
  /** User-friendly name (defaults to directory name) */
  name: string
  /** How the session was created */
  type: SessionType
  /** Which agent is running */
  agent: AgentType
  /** Current session status */
  status: SessionStatus
  /** Working directory */
  cwd: string
  /** When the session was created (ms since epoch) */
  createdAt: number
  /** Last activity timestamp (ms since epoch) */
  lastActivity: number

  // Internal sessions only
  /** tmux session name (e.g., "bridge-a1b2c3d4") */
  tmuxSession?: string

  // Agent session identifiers
  /** Agent's internal session ID (Claude's sessionId, Codex's threadId, etc.) */
  agentSessionId?: string

  // External session info
  /** Terminal info for external sessions */
  terminal?: TerminalInfo

  // Current state
  /** Currently executing tool, if any */
  currentTool?: string
}

/**
 * Options for creating a new internal session.
 */
export interface CreateSessionOptions {
  /** Session name (defaults to directory name) */
  name?: string
  /** Working directory (defaults to user's home or configured default) */
  cwd?: string
  /** Agent to use (defaults to config.defaultAgent) */
  agent?: AgentType
  /** Agent-specific flags */
  flags?: Record<string, boolean | string>
}

/**
 * Filter options for listing sessions.
 */
export interface SessionFilter {
  /** Filter by session type */
  type?: SessionType
  /** Filter by agent */
  agent?: AgentType
  /** Filter by status */
  status?: SessionStatus
  /** Filter by status (multiple) */
  statuses?: SessionStatus[]
}

// =============================================================================
// Event Types
// =============================================================================

/**
 * Event types emitted by agents via hooks.
 */
export type EventType =
  | 'pre_tool_use'
  | 'post_tool_use'
  | 'stop'
  | 'subagent_stop'
  | 'session_start'
  | 'session_end'
  | 'user_prompt_submit'
  | 'notification'

/**
 * Base event interface shared by all events.
 */
export interface BaseEvent {
  /** Unique event ID (UUID) */
  id: string
  /** Event timestamp (ms since epoch) */
  timestamp: number
  /** Event type */
  type: EventType
  /** Bridge session ID (normalized from agent session ID) */
  sessionId: string
  /** Original agent session ID */
  agentSessionId?: string
  /** Which agent generated this event */
  agent: AgentType
  /** Working directory when event occurred */
  cwd: string
}

/**
 * Pre-tool use event - emitted before a tool executes.
 */
export interface PreToolUseEvent extends BaseEvent {
  type: 'pre_tool_use'
  /** Tool name (e.g., "Bash", "Read", "Edit") */
  tool: string
  /** Tool input parameters */
  toolInput: Record<string, unknown>
  /** Tool use ID for correlating with post_tool_use */
  toolUseId: string
  /** Assistant's text before the tool call */
  assistantText?: string
}

/**
 * Post-tool use event - emitted after a tool completes.
 */
export interface PostToolUseEvent extends BaseEvent {
  type: 'post_tool_use'
  /** Tool name */
  tool: string
  /** Tool input parameters */
  toolInput: Record<string, unknown>
  /** Tool response/output */
  toolResponse: Record<string, unknown>
  /** Tool use ID for correlating with pre_tool_use */
  toolUseId: string
  /** Whether the tool succeeded */
  success: boolean
  /** Duration in milliseconds (computed from pre/post timestamps) */
  duration?: number
}

/**
 * Stop event - emitted when the agent finishes responding.
 */
export interface StopEvent extends BaseEvent {
  type: 'stop'
  /** Whether a stop hook is active */
  stopHookActive: boolean
  /** Agent's final response text */
  response?: string
}

/**
 * Subagent stop event - emitted when a subagent completes.
 */
export interface SubagentStopEvent extends BaseEvent {
  type: 'subagent_stop'
  /** Subagent status */
  status?: string
}

/**
 * Session start event - emitted when an agent session begins.
 */
export interface SessionStartEvent extends BaseEvent {
  type: 'session_start'
  /** Source of the session start */
  source: string
  /** Terminal info (captured from environment) */
  terminal?: TerminalInfo
}

/**
 * Session end event - emitted when an agent session ends.
 */
export interface SessionEndEvent extends BaseEvent {
  type: 'session_end'
  /** Reason for session end */
  reason?: string
}

/**
 * User prompt submit event - emitted when user sends a prompt.
 */
export interface UserPromptSubmitEvent extends BaseEvent {
  type: 'user_prompt_submit'
  /** The prompt text */
  prompt?: string
}

/**
 * Notification event - emitted for agent notifications.
 */
export interface NotificationEvent extends BaseEvent {
  type: 'notification'
  /** Notification message */
  message?: string
  /** Notification type/level */
  level?: string
}

/**
 * Union type of all event types.
 */
export type AgentEvent =
  | PreToolUseEvent
  | PostToolUseEvent
  | StopEvent
  | SubagentStopEvent
  | SessionStartEvent
  | SessionEndEvent
  | UserPromptSubmitEvent
  | NotificationEvent

// =============================================================================
// Configuration
// =============================================================================

/**
 * Bridge configuration options.
 */
export interface BridgeConfig {
  /** Data directory for storing sessions, events, etc. Default: ~/.claude-tmux-bridge */
  dataDir?: string

  /** Server port for HTTP/WebSocket. Default: 4003 */
  port?: number

  /** Default agent type for new sessions. Default: 'claude' */
  defaultAgent?: AgentType

  /** Enabled agent types. Default: ['claude', 'codex'] */
  agents?: AgentType[]

  /** Whether to track external sessions via hooks. Default: true */
  trackExternalSessions?: boolean

  /** Timeout (ms) before marking working sessions as idle. Default: 120000 (2 min) */
  workingTimeoutMs?: number

  /** Time (ms) before cleaning up offline sessions. Default: 7 days */
  cleanupOfflineAfterMs?: number

  /** Maximum events to keep in memory. Default: 1000 */
  maxEvents?: number

  /** Enable debug logging. Default: false */
  debug?: boolean
}

/**
 * Resolved configuration with all defaults applied.
 */
export interface ResolvedConfig extends Required<BridgeConfig> {
  /** Resolved paths */
  paths: {
    /** Events file path */
    eventsFile: string
    /** Sessions file path */
    sessionsFile: string
    /** Hooks directory */
    hooksDir: string
  }
}

// =============================================================================
// Agent Adapter
// =============================================================================

/**
 * Hook configuration for an agent.
 */
export interface HookConfig {
  /** Hook names to install */
  hookNames: string[]
  /** Path to the agent's settings file */
  settingsPath: string
  /** Timeout for hook execution (seconds) */
  timeout: number
}

/**
 * Options for building an agent command.
 */
export interface AgentCommandOptions {
  /** Agent-specific flags */
  flags?: Record<string, boolean | string>
  /** Working directory */
  cwd?: string
}

/**
 * Agent adapter interface - implement this to support new AI coding assistants.
 */
export interface AgentAdapter {
  /** Agent type identifier (e.g., 'claude', 'codex') */
  readonly name: AgentType

  /** Human-readable agent name (e.g., "Claude Code", "OpenAI Codex") */
  readonly displayName: string

  /**
   * Build the command to start the agent.
   * @param options Command options
   * @returns The shell command to execute
   */
  buildCommand(options?: AgentCommandOptions): string

  /**
   * Parse raw hook data into a normalized event.
   * @param hookName The hook that fired (e.g., "PreToolUse", "Stop")
   * @param data Raw hook data from stdin
   * @returns Parsed event or null if invalid
   */
  parseHookEvent(hookName: string, data: unknown): Partial<AgentEvent> | null

  /**
   * Extract the agent's session ID from an event.
   * @param event The parsed event
   * @returns Agent session ID or undefined
   */
  extractSessionId(event: Partial<AgentEvent>): string | undefined

  /**
   * Get hook configuration for this agent.
   * @returns Hook configuration
   */
  getHookConfig(): HookConfig

  /**
   * Get the path to the agent's settings file.
   * @returns Absolute path to settings file
   */
  getSettingsPath(): string

  /**
   * Install hooks for this agent.
   * @param hookScriptPath Path to the hook script to install
   */
  installHooks(hookScriptPath: string): Promise<void>

  /**
   * Uninstall hooks for this agent.
   */
  uninstallHooks(): Promise<void>

  /**
   * Check if this agent is available on the system.
   * @returns True if the agent CLI is installed and accessible
   */
  isAvailable(): Promise<boolean>
}

// =============================================================================
// Bridge API
// =============================================================================

/**
 * Image input for sending with prompts.
 */
export interface ImageInput {
  /** Base64-encoded image data */
  data: string
  /** MIME type (e.g., "image/png", "image/jpeg") */
  mediaType: string
  /** Optional filename */
  name?: string
}

/**
 * Result of sending a prompt to a session.
 */
export interface SendResult {
  /** Whether the send succeeded */
  ok: boolean
  /** Error message if failed */
  error?: string
  /** Paths to saved images (if any) */
  imagePaths?: string[]
}

/**
 * Bridge event types for EventEmitter.
 */
export interface BridgeEvents {
  /** Emitted for every agent event */
  event: (event: AgentEvent) => void
  /** Emitted when a session is created */
  'session:created': (session: Session) => void
  /** Emitted when a session is updated */
  'session:updated': (session: Session, changes: Partial<Session>) => void
  /** Emitted when a session is deleted */
  'session:deleted': (session: Session) => void
  /** Emitted when a session's status changes */
  'session:status': (session: Session, from: SessionStatus, to: SessionStatus) => void
  /** Emitted on errors */
  error: (error: Error) => void
}

/**
 * Main Bridge interface.
 */
export interface Bridge {
  // === Lifecycle ===

  /**
   * Start the bridge (file watcher, health checks, etc.)
   */
  start(): Promise<void>

  /**
   * Stop the bridge and clean up resources.
   */
  stop(): Promise<void>

  /**
   * Check if the bridge is running.
   */
  isRunning(): boolean

  // === Sessions ===

  /**
   * Create a new internal session.
   * @param options Session creation options
   * @returns The created session
   */
  createSession(options?: CreateSessionOptions): Promise<Session>

  /**
   * Get a session by ID.
   * @param id Session ID
   * @returns Session or undefined if not found
   */
  getSession(id: string): Session | undefined

  /**
   * List all sessions, optionally filtered.
   * @param filter Optional filter criteria
   * @returns Array of sessions
   */
  listSessions(filter?: SessionFilter): Session[]

  /**
   * Delete a session.
   * @param id Session ID
   * @returns True if deleted, false if not found
   */
  deleteSession(id: string): Promise<boolean>

  /**
   * Update a session's properties.
   * @param id Session ID
   * @param updates Properties to update
   * @returns Updated session or undefined if not found
   */
  updateSession(id: string, updates: Partial<Pick<Session, 'name'>>): Session | undefined

  // === Session Control (internal sessions only) ===

  /**
   * Send a prompt to a session.
   * @param id Session ID
   * @param prompt Prompt text
   * @param images Optional images to include
   * @returns Send result
   */
  sendPrompt(id: string, prompt: string, images?: ImageInput[]): Promise<SendResult>

  /**
   * Cancel (Ctrl+C) a session.
   * @param id Session ID
   * @returns True if cancelled, false if not found or not internal
   */
  cancel(id: string): Promise<boolean>

  /**
   * Restart a session.
   * @param id Session ID
   * @returns Restarted session
   */
  restart(id: string): Promise<Session>

  // === Agents ===

  /**
   * Register a custom agent adapter.
   * @param adapter Agent adapter to register
   */
  registerAgent(adapter: AgentAdapter): void

  /**
   * Get an agent adapter by name.
   * @param name Agent type name
   * @returns Agent adapter or undefined
   */
  getAgent(name: AgentType): AgentAdapter | undefined

  /**
   * List all registered agent adapters.
   * @returns Array of agent adapters
   */
  listAgents(): AgentAdapter[]

  // === Server ===

  /**
   * Start the HTTP/WebSocket server.
   * @param port Optional port override
   */
  listen(port?: number): Promise<void>

  /**
   * Stop the server.
   */
  close(): Promise<void>

  // === Events ===

  /**
   * Subscribe to bridge events.
   */
  on<K extends keyof BridgeEvents>(event: K, handler: BridgeEvents[K]): this

  /**
   * Unsubscribe from bridge events.
   */
  off<K extends keyof BridgeEvents>(event: K, handler: BridgeEvents[K]): this

  /**
   * Subscribe to an event once.
   */
  once<K extends keyof BridgeEvents>(event: K, handler: BridgeEvents[K]): this

  // === Configuration ===

  /**
   * Get the resolved configuration.
   */
  readonly config: ResolvedConfig
}
